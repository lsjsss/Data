@[TOC](数据结构课后习题  | Data)
# 第 1 章 绪论
## 1. 简述数据与数据元素的关系与区别。
> 答：凡是能被计算机存储、加工的对象统称为数据，数据是一个集合。数据元素是数据的基本单位，是数据的个体。数据元素与数据之间的关系是元素与集合之间的关系。
## 2. 采用二元组表示的数据逻辑结构 
采用二元组表示的数据逻辑结构 S=<D，R>，其中 D={a，b，**···**，i}，R={r}，r={<a，b>，<a，c>，<c，d>，<c，f>，<f，h>，<d，e>，<f，g>，<h，i>}，问关系 r 是什么类型的逻辑结构？哪些结点是开始结点，哪些结点是终端结点？
> 答：该逻辑结构为树形结构，其中 a 结点没有前驱结点，它是开始结点，b、e、i 和 g、
结点没有后继结点，它们都是终端结点。
## 3. 简述数据逻辑结构与存储结构的关系。
> 答：在数据结构中，逻辑结构与计算机无关，存储结构是数据元素之间的逻辑关系在计算机中的表示。存储结构不仅将逻辑结构中所有数据元素存储到计算机内存中，而且还要在内存中存储各数据元素间的逻辑关系。通常情况下，一种逻辑结构可以有多种存储结构，例如，线性结构可以采用顺序存储结构或链式存储结构表示。
## 4. 简述数据结构中运算描述和运算实现的异同。
> 答：运算描述是指逻辑结构施加的操作，而运算实现是指一个完成该运算功能的算法。它们的相同点是，运算描述和运算实现都能完成对数据的“处理”或某种特定的操作。不同点是，运算描述只是描述处理功能，不包括处理步骤和方法，而运算实现的核心则是设
计处理步骤。
## 5. 数据结构和数据类型有什么区别？
> 答：数据结构是相互之间存在一种或多种特定关系的数据元素的集合，一般包括三个
方面的内容，即数据的逻辑结构、存储结构和数据的运算。而数据类型是一个值的集合和
定义在这个值集上的一组运算的总称，如C语言中的short int数据类型是由-32768～32767
（16位机）的整数和+、-、*、/、%等运算符构成。
## 6. 在 C/C++中提供了引用运算符，简述其在算法描述中的主要作用。
> 答：在算法设计中，一个算法通常用一个或多个 C/C++函数来实现，在 C/C++函数之间传递参数时有两种情况，一是从实参到形参的单向值传递，二是实参和形参之间的双向值传递。对形参使用引用运算符，即在形参名前加上“&”，不仅可以实现实参和形参之间的双向值传递，而且使算法设计简单明晰。

## 7. 有以下用 C/C++语言描述的算法，说明其功能：
```c
void fun(double &y,double x,int n)
{	y=x;
	while (n>1)
	{	y=y*x;
		n--;
	}
}
```
> 答：本算法的功能是计算 y= $x^{n}$。
## 8. 用 C/C++语言描述下列算法，并给出算法的时间复杂度。
（1）求一个 n 阶整数数组的所有元素之和。
（2）对于输入的任意 3 个整数，将它们按从小到大的顺序输出。
（3）对于输入的任意 n 个整数，输出其中的最大和最小元素。
> 答：（1）算法如下：
> ```c
> int sum(int A[N][N],int n)
> {	int i,j,s=0;
> 	for (i=0;i<n;i++)
> 		for (j=0;j<n;j++)
> 			s=s+A[i][j];
> 	return(s);
> }
> ```
> 本算法的时间复杂度为 O($n^{2}$)。
> &nbsp;
> （2）算法如下：
> ```c
> void order(int a,int b,int c)
> {	if (a>b)
> 	{	if (b>c)
> 			printf("%d,%d,%d\n",c,b,a);
> 		else if (a>c)
> 			printf("%d,%d,%d\n",b,c,a);
> 		else
> 			printf("%d,%d,%d\n",b,a,c);
> 	}
> 	else
> 	{	if (b>c)
> 		{	if (a>c)
> 				printf("%d,%d,%d\n",c,a,b);
> 			else
> 				printf("%d,%d,%d\n",a,c,b);
> 		}
> 		else printf("%d,%d,%d\n",a,b,c);
> 	}
> }
> ```
> 本算法的时间复杂度为 O(1)。
> &nbsp;
> （3）算法如下：
> ```c
> void maxmin(int A[],int n,int &max,int &min) 
> {	int i;
> 	min=min=A[0];
> 	for (i=1;i<n;i++)
> 	{	if (A[i]>max) max=A[i];
> 		if (A[i]<min) min=A[i];
> 	}
> }
> ```
> 本算法的时间复杂度为 O(n)。

## 9. 设 3 个表示算法频度的函数 f、g 和 h 分别为：
&emsp;&emsp; $f(n)=100n^{3}＋n^{2}+1000$
&emsp;&emsp; $g(n)=25n^{3}＋5000n^{2}$
&emsp;&emsp; $h(n)=n^{1.5}＋5000nlog_2n$
&emsp;&emsp; 求它们对应的时间复杂度。
> 答：$f(n)=100n^{3}＋n^{2}+1000=O(n^{3})，g(n)=25n{3}＋5000n^{2}=O(n^{3})$
当$n \to \infty时， \sqrt{n}＞log_2n，所以h(n)=n^{1.5}＋5000nlog_2n=O(n^{1.5})$。
## 10. 分析下面程序段中循环语句的执行次数。
```c
int j=0,s=0,n=100;
do
{	j=j+1;
	s=s+10*j;
} while (j<n && s<n);
```
> 答：$j$=0，第 1 次循环：$j$=1，$s$=10。第 2 次循环：$j$=2，$s$=30。第 3 次循环：$j$=3，$s$=60。第 4 次循环：$j$=4，$s$=100。while 条件不再满足。所以，其中循环语句的执行次数为 4。
## 11. 设 n 为正整数，给出下列 3 个算法关于问题规模 n 的时间复杂度。
（1）算法 1
```c
void fun1(int n)
{	i=1,k=100;
	while (i<=n)
	{	k=k+1;
		i+=2;
	}
}
```
（2）算法 2
```c
void fun2(int b[]，int n)
{	int i，j，k，x;
	for (i=0;i<n-1;i++)
	{	k=i;
		for (j=i+1;j<n;j++)
			if (b[k]>b[j]) k=j;
		x=b[i];b[i]=b[k];b[k]=x;
	}
}
```
（3）算法 3
```c
void fun3(int n)
{	int i=0,s=0;
	while (s<=n)
	{	i++;
		s=s+i;
	}
}
```
> 答：（1）设 while 循环语句执行次数为 T(n)，则：
$i = T(n) + 1\leqslant n$，即 $T(n) \leqslant (n-1)/2=O(n)$。
（2）算法中的基本运算语句是 if ($b[k] > b[j]) k=j$，其执行次数 $T(n)$为：
$$T(n)= \sum_{i=0}^{n-2} \sum_{j=i+1}^{n-1} 1 = \sum_{i=0}^{n-2} (n-i-1) = \frac{n(n-1)}{2} = O(n^{2})$$
（3）设 while 循环语句执行次数为 T(n)，则：
$$s=1+2+**···**+T(n)=\frac{T(n)(T(n)+1)}{2} \leqslant n$$，则 T(n)=O($\sqrt n$)。
## 12. 有以下递归算法用于对数组 a[i..j]的元素进行归并排序：
```c
void mergesort(int a[],int i,int j)
{	int m;
	if (i!=j)
	{	m=(i+j)/2;
		mergesort(a,i,m);
		mergesort(a,m+1,j);
		merge(a,i,j,m);
	}
}
```
求执行 mergesort($a，0，n-1$)的时间复杂度。其中，merge($a，i，j，m$)用于两个有序子序列 $a[i..m]$ 和 $a[m+1..j]$ 的合并，是非递归函数，它的时间复杂度为 O(合并的元素个数)。
> 答：设 mergesort($a，0，n-1$)的执行时间为 $T(n)$，分析得到以下递归关系：
$T(n)= O(1)$ &emsp;&emsp;&emsp;&emsp;&emsp;&emsp; $n=1$
$T(n)=2T( \frac{n}{2})+O(n)$ &nbsp;&emsp; $n>1$
其中，O(n)为 merge()所需的时间，设为 cn（c 为常量）。因此：
$$\begin{aligned}
T(n)  &=2T( \frac{n}{2} ) +cn=2(2T( \frac{n}{2^{2}} ) + \frac{cn}{2}) + cn = 2^{2}T( \frac{n}{2^{2}} )  + 2cn = 2^{3}T( \frac{n}{2^{3}} )  + 3cn \\
&=2^{k} T(\frac{n}{2^{k}} + kcn ) =  2^{k} O(1) + kcn
\end{aligned}$$
由于 $\frac{n}{2^{k}}$ 趋近于 1，则 $k=log_2n$。所以 T(n) = $2^{log_2n}$ O(1) + $cnlog_2n = n + cnlog_2n = O(nlog_2n)$。
## 13. 描述一个集合的抽象数据类型 ASet，其中所有元素为正整数，集合的基本运算包括：
&emsp;&emsp; （1）由整数数组 a[0..n-1]创建一个集合。
&emsp;&emsp; （2）输出一个集合的所有元素。
&emsp;&emsp; （3）判断一个元素是否在一个集合中。
&emsp;&emsp; （4）求两个集合的并集。
&emsp;&emsp; （5）求两个集合的差集。
&emsp;&emsp; （6）求两个集合的交集。
&emsp;&emsp; 在此基础上设计集合的顺序存储结构，并实现各基本运算的算法。
> 答：抽象数据类型 ASet 的描述如下：
> **ADT  ASet**
> { &nbsp; &nbsp; &nbsp; 数据对象：$D$ = { $d_{i}$ | 0 $\leqslant i \leqslant n$，n为一个正整数}
> 	 &nbsp; &nbsp; &nbsp;  &nbsp;&nbsp;数据关系：无。
> 	 &nbsp; &nbsp; &nbsp;  &nbsp;&nbsp;基本运算：
> 	 &nbsp; &nbsp; &nbsp;  &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;  &nbsp;&nbsp;	createset( &s，a，n)：创建一个集合s;
> 	 &nbsp; &nbsp; &nbsp;  &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;  &nbsp;&nbsp;	dispset( s)：输出集合s;
> 	 &nbsp; &nbsp; &nbsp;  &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;  &nbsp;&nbsp;	inset(s,e)：判断元素e是否在集合s中。
> 	 &nbsp; &nbsp; &nbsp;  &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;  &nbsp;&nbsp;	void add(s1，s2，s3)：s3=s1∪s2;	//求集合的并集
> 	 &nbsp; &nbsp; &nbsp;  &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;  &nbsp;&nbsp;	void sub(s1，s2，s3)：s3=s1-s2;	//求集合的差集
> 	 &nbsp; &nbsp; &nbsp;  &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;  &nbsp;&nbsp;	void intersection(s1，s2，s3)：s3=s1∩s2;	//求集合的交集
> 	}
> &nbsp;
> 设计集合的顺序存储结构类型如下：
> ```c
> typedef struct //集合结构体类型
> {	int data[MaxSize]; //存放集合中的元素，其中 MaxSize 为常量
> 	int length; //存放集合中实际元素个数
> } Set; //将集合结构体类型用一个新类型名 Set 表示
> ```
> 采用 **Set** 类型的变量存储一个集合。对应的基本运算算法设计如下：
> ```c
> void createset(Set &s,int a[],int n) //创建一个集合
> {	int i;
> 	for (i=0;i<n;i++)
> 		s.data[i]=a[i];
>	s.length=n;
> }
> 
> void dispset(Set s) //输出一个集合
> {	int i;
> 	for (i=0;i<s.length;i++)
> 		printf("%d ",s.data[i]);
> 	printf("\n");
> }
> 
> bool inset(Set s,int e) //判断 e 是否在集合 s 中
> {	int i;
> 	for (i=0;i<s.length;i++)
> 		if (s.data[i]==e)
> 			return true;
> 	return false;
> }
> 
> void add(Set s1,Set s2,Set &s3) //求集合的并集
> {	int i;
> 	for (i=0;i<s1.length;i++) //将集合 s1 的所有元素复制到 s3 中
> 		s3.data[i]=s1.data[i];
> 	s3.length=s1.length;
> 	for (i=0;i<s2.length;i++) //将 s2 中不在 s1 中出现的元素复制到 s3 中
> 		if (!inset(s1,s2.data[i]))
> 		{	s3.data[s3.length]=s2.data[i];
> 			s3.length++;
> 		}
> }
> 
> void sub(Set s1,Set s2,Set &s3) //求集合的差集
> {	int i;
> 	s3.length=0;
> 	for (i=0;i<s1.length;i++) //将 s1 中不出现在 s2 中的元素复制到 s3 中
> 		if (!inset(s2,s1.data[i]))
> 		{	s3.data[s3.length]=s1.data[i];
> 			s3.length++;
> 		}
> }
> 
> void intersection(Set s1,Set s2,Set &s3) //求集合的交集
> {	int i;
> 		s3.length=0;
> 		for (i=0;i<s1.length;i++) //将 s1 中出现在 s2 中的元素复制到 s3 中
> 			if (inset(s2,s1.data[i]))
> 			{	s3.data[s3.length]=s1.data[i];
> 				s3.length++;
> 			}
> }

# 第 2 章 线性表
## 1. 简述线性表两种存储结构各自的主要特点。
> 答：线性表的两种存储结构分别是顺序存储结构和链式存储结构。顺序存储结构的主要特点如下：
&emsp;&emsp; ① 数据元素中只有自身的数据域，没有关联指针域。因此，顺序存储结构的存储密度较大。
&emsp;&emsp; ② 顺序存储结构需要分配一整块比较大存储空间，所以存储空间利用率较低。
&emsp;&emsp; ③ 逻辑上相邻的两个元素在物理上也是相邻的，通过元素的逻辑序号可以直接其元素值，即具有随机存取特性。
&emsp;&emsp; ④ 插入和删除操作会引起大量元素的移动。
&emsp;&emsp; 链式存储结构的主要特点如下：
&emsp;&emsp; ① 数据结点中除自身的数据域，还有表示逻辑关系的指针域。因此，链式存储结构比顺序存储结构的存储密度小。
&emsp;&emsp; ② 链式存储结构的每个结点是单独分配的，每个结点的存储空间相对较小，所以存储空间利用率较高。
&emsp;&emsp; ③ 在逻辑上相邻的结点在物理上不一定相邻，因此不具有随机存取特性。
&emsp;&emsp; ④ 插入和删除操作方便灵活，不必移动结点，只需修改结点中的指针域即可。
## 2. 简述单链表设置头结点的主要作用。
> 答：对单链表设置头结点的主要作用如下：
&emsp;&emsp; ① 对于带头结点的单链表，在单链表的任何结点之前插入结点或删除结点，所要做的都是修改前一个结点的指针域，因为任何结点都有前驱结点（若单链表没有头结点，则首结点没有前驱结点，在其前插入结点和删除该结点时操作复杂些），所以算法设计方便。
&emsp;&emsp; ② 对于带头结点的单链表，在表空时也存在一个头结点，因此空表与非空表的处理是一样的。
## 3. 假设某个含有n个元素的线性表有如下运算：
&emsp;&emsp; Ⅰ. 查找序号为i（1≤i≤n）的元素
&emsp;&emsp; Ⅱ. 查找第一个值为x的元素
&emsp;&emsp; Ⅲ. 插入新元素作为第一个元素
&emsp;&emsp; Ⅳ. 插入新元素作为最后一个元素
&emsp;&emsp; Ⅴ. 插入第i（2≤i≤n）个元素
&emsp;&emsp; Ⅵ. 删除第一个元素
&emsp;&emsp; Ⅶ. 删除最后一个元素
&emsp;&emsp; Ⅷ. 删除第i（2≤i≤n）个元素
&emsp;&emsp; 现设计该线性表的如下存储结构：
&emsp;&emsp; ① 顺序表
&emsp;&emsp; ② 带头结点的单链表
&emsp;&emsp; ③ 带头结点的循环单链表
&emsp;&emsp; ④ 不带头结点仅有尾结点指针标识的循环单链表
&emsp;&emsp; ⑤ 带头结点的双链表
&emsp;&emsp; ⑥ 带头结点的循环双链表
&emsp;&emsp; 指出各种存储结构中对应运算算法的时间复杂度。
> 答：各种存储结构对应运算的时间复杂度如表2.1所示。
> 表 2.1 各种存储结构对应运算的时间复杂度
>  - | Ⅰ. 查找序号为i（1≤i≤n）的元素 | Ⅱ. 查找第一个值为x的元素 | Ⅲ. 插入新元素作为第一个元素 | Ⅳ. 插入新元素作为最后一个元素 | Ⅴ. 插入第i（2≤i≤n）个元素 | Ⅵ. 删除第一个元素 | Ⅶ. 删除最后一个元素 | Ⅷ. 删除第i（2≤i≤n）个元素
> -- | -- | -- | -- | -- | -- | -- | -- | -- | --
> ①顺序表 | O(1) | O(n) | O(n) | O(1) | O(n) | O(n) | O(1) | O(n)
> ②带头结点的单链表 | O(n) | O(n) | O(1) | O(n) | O(n) | O(1) | O(n) | O(n)
> ③带头结点的循环单链表 | O(n) | O(n) | O(1) | O(n) | O(n) | O(1) | O(n) | O(n)
> ④不带头结点仅有尾结点指针标识的循环单链表 | O(n) | O(n) | O(1) | O(1) | O(n) | O(1) | O(n) | O(n)
> ⑤带头结点的双链表 | O(n) | O(n) | O(1)  |O(n) | O(n) | O(1) | O(n) | O(n)
> ⑥带头结点的循环双链表 | O(n) | O(n) | O(1) | O(1) | O(n) | O(1) | O(1) | O(n)
> 

## 4. 对于顺序表 L，指出以下算法的功能。
```c
void fun(SqList *&L)
{	int i,j=0;
	for (i=1;i<L->length;i++)
		if (L->data[i]>L->data[j])
			j=i;
	for (i=j;i<L->length-1;i++)
		L->data[i]=L->data[i+1];
	L->length--;
}
```
> 答：该算法的功能是在顺序表 L 中查找第一个值最大的元素，并删除该元素。

## 5. 对于顺序表 L，指出以下算法的功能。
```c
void fun(SqList *&L,ElemType x)
{	int i,j=0;
	for (i=1;i<L->length;i++)
		if (L->data[i]<=L->data[j])
			j=i;
	for (i=L->length;i>j;i--)
		L->data[i]=L->data[i-1];
	L->data[j]=x;
	L->length++;
}
```
> 答：在顺序表 L 中查找最后一个值最小的元素，在该位置上插入一个值为 x 的元素。

## 6. 有人设计如下算法用于删除整数顺序表 L 中所有值在[x，y]范围内的元素，该算法显然不是高效的，请设计一个同样功能的高效算法。
```c
void fun(SqList *&L,ElemType x)
{	int i,j;
	for (i=0;i<L->length;i++)
		if (L->data[i]>=x && L->data[i]<=y)
		{	for (j=i;j<L->length-1;j++)
				L->data[j]=L->data[j+1];
			L->length--;
		}
}
```
> 答：该算法在每次查找到 x 元素时，都通过移动来删除它，时间复杂度为 O($n^{2}$)，显然不是高效的算法。实现同样功能的算法如下：
> ```c
> void fun(SqList *&L,ElemType x,ElemType y)
> {	int i,k=0;
> 	for (i=0;i<L->length;i++)
> 		if (!(L->data[i]>=x && L->data[i]<=y))
> 		{	L->data[k]=L->data[i];
> 			k++;
> 		}
> 	L->length=k;
> }
&emsp;&emsp;该算法（思路参见《教程》例 2.3 的解法一）的时间复杂度为 O(n)，是一种高效的算法。

## 7. 设计一个算法，将元素x插入到一个有序（从小到大排序）顺序表的适当位置上，并保持有序性。
> 解：通过比较在顺序表 L 中找到插入 x 的位置 i，将该位置及后面的元素均后移一个位置，将 x 插入到位置 i 中，最后将 L 的长度增 1。对应的算法如下：
> ```c
> void Insert(SqList *&L,ElemType x)
> {	int i=0,j;
> 	while (i<L->length && L->data[i]<x) i++;
> 	for (j=L->length-1;j>=i;j--)
> 		L->data[j+1]=L->data[j];
> 	L->data[i]=x;
> 	L->length++;
> }
> ```

## 8. 假设一个顺序表 L 中所有元素为整数，设计一个算法调整该顺序表，使其中所有小于零的元素放在所有大于等于零的元素的前面。
> 解：先让 i、j 分别指向顺序表 L 的第一个元素和最后一个元素。当 i<j 时循环：i 从前向后扫描顺序表 L，找大于等于 0 的元素，j 从后向前扫描顺序表 L，找小于 0 的元素，当i<j 时将两元素交换（思路参见《教程》例 2.4 的解法一）。对应的算法如下：
> ```c
> void fun(SqList *&L)
> {	int i=0,j=L->length-1;
> 	while (i<j)
> 	{	while (L->data[i]<0) i++;
> 		while (L->data[j]>=0) j--;
> 		if (i<j) //L->data[i]与 L->data[j]交换
> 			swap(L->data[i], L->data[j]);
> 	}
> }
> ```

## 9. 对于不带头结点的单链表 L1，其结点类在为 LinkNode，指出以下算法的功能。
```c 
void fun1(LinkNode *&L1,LinkNode *&L2)
{	int n=0,i;
	LinkNode *p=L1;
	while (p!=NULL)
	{	n++;
		p=p->next;
	}
	p=L1;
	for (i=1;i<n/2;i++)
		p=p->next;
	L2=p->next;
	p->next=NULL;
}
```
> 答：对于含有 $n$ 个结点的单链表 $L1$，将 $L1$ 拆分成两个不带头结点的单链表 $L1$ 和 $L2$，其中 $L1$ 含有原来的前 $n$/2 个结点，$L2$ 含有余下的结点。

## 10. 在结点类型为 DLinkNode 的双链表中，给出将 p 所指结点（非尾结点）与其后继结点交换的操作。
> 答：将 $p$ 所指结点（非尾结点）与其后继结点交换的操作如下：
> ```c
> q=p->next; //q 指向结点 p 的后继结点
> if (q->next!=NULL) //从链表中删除结点 p
> 	q->next->prior=p;
> p->next=q->next;
> p->prior->next=q; //将结点 q 插入到结点 p 的前面
> q->prior=p->prior;
> q->next=p;
> p->prior=q;
> ```
## 11. 有一个线性表($a_{1}，a_{2}，…，a_{n}$)，其中 n≥2，采用带头结点的单链表存储，头指针为 $L$，每个结点存放线性表中一个元素，结点类型为（$data，next$），现查找某个元素值等于 $x$ 的结点指针，若不存在这样的结点返回 NULL。分别写出下面 3 种情况的查找语句。要求时间尽量少。
&emsp;&emsp;（1）线性表中元素无序。
&emsp;&emsp;（2）线性表中元素按递增有序。
&emsp;&emsp;（3）线性表中元素按递减有序。
> 答：（1）元素无序时的查找语句如下：
> ```c
> p=L->next;
> while (p!=NULL && p->data!=x)
> p=p->next;
> if (p==NULL) return NULL;
> else return p;
> ```
>（2）元素按递增有序时的查找语句如下：
> ```c
> p=L->next;
> while (p!=NULL && p->data<x )
> p=p->next;
> if (p==NULL || p->data>x) return NULL;
> else return p;
> ```
>（3）元素按递减有序时的查找语句如下：
> ```c
> p=L->next;
> while (p!=NULL && p->data>x)
> p=p->next;
> if (p==NULL || p->data<x) return NULL;
> else return p;
> ```

## 12. 设计一个算法，将一个带头结点的数据域依次为 $a_{1}、a_{2}、…、a_{n}（n≥3）$的单链表的所有结点逆置，即第一个结点的数据域变为 $a_{n}$，第 2 个结点的数据域变为 $a_{n-1}$，…，尾结点的数据域为 a1。
> 解：首先让 p 指针指向首结点，将头结点的 next 域设置为空，表示新建的单链表为空表。用 p 扫描单链表的所有数据结点，将结点 p 采用头插法插入到新建的单链表中。对应的算法如下：
> ```c
> void Reverse(LinkNode *&L)
> {	LinkNode *p=L->next,*q;
> 	L->next=NULL;
> 	while (p!=NULL) //扫描所有的结点
> 	{	q=p->next; //q 临时保存 p 结点的后继结点
> 		p->next=L->next; //总是将 p 结点作为首结点插入
> 		L->next=p;
> 		p=q; //让 p 指向下一个结点
> 	}
> }
> ```

## 13. 一个线性表（$a_{1}，a_{2}，…，a_{n}$）（$n$>3）采用带头结点的单链表 $L$ 存储。设计一个高效算法求中间位置的元素（即序号为 [n/2] 的元素）。
>解：让 $p、q$ 首先指向首结点，然后在 p 结点后面存在两个结点时循环：p 后移两个结点，q 后移一个结点。当循环结束后，q 指向的就是中间位置的结点，对应的算法如下：
>```c
> ElemType Midnode(LinkNode *L)
> {	LinkNode *p=L->next,*q=p;
> 	while (p->next!=NULL && p->next->next!=NULL)
> 	{	p=p->next->next;
> 		q=q->next;
> 	}
> 	return q->data;
> }
> ```

## 14. 设计一个算法在带头结点的非空单链表 L 中第一个最大值结点（最大值结点可能有多个）之前插入一个值为 x 的结点。
> 解：先在单链表 $L$ 中查找第一个最大值结点的前驱结点 $maxpre$，然后在其后面插入值为 $x$ 的结点。对应的算法如下：
> ```c
> void Insertbeforex(LinkNode *&L,ElemType x)
> {	LinkNode *p=L->next,*pre=L;
> 	LinkNode *maxp=p,*maxpre=L,*s;
> 	while (p!=NULL)
> 	{	if (maxp->data < p->data)
> 		{	maxp=p;
> 			maxpre=pre;
> 		}
> 		pre=p; p=p->next;
> 	}
> 	s=(LinkNode *)malloc(sizeof(LinkNode));
> 	s->data=x;
> 	s->next=maxpre->next;
> 	maxpre->next=s;
> }
> ```

## 15. 设有一个带头结点的单链表 L，结点的结构为（data，next），其中 data 为整数元素，next 为后继结点的指针。设计一个算法，首先按递减次序输出该单链表中各结点的数据元素，然后释放所有结点占用的存储空间，并要求算法的空间复杂度为 O(1)。
> 解：先对单链表 L 的所有结点递减排序（思路参见《教程》例 2.8），再输出所有结点值，最后释放所有结点的空间。对应的算法如下：
> ```c
> void Sort(LinkNode *&L) //对单链表 L 递减排序
> {	LinkNode *p,*q,*pre;
> 	p=L->next->next; //p 指向第 2 个数据结点
> 	L->next->next=NULL;
> 	while (p!=NULL)
> 	{	q=p->next;
> 		pre=L;
> 		while (pre->next!=NULL && pre->next->data>p->data)
> 		pre=pre->next;
> 		p->next=pre->next; //在结点 pre 之后插入 p 结点
> 		pre->next=p;
> 		p=q;
> 	}
> }
> 
> void fun(LinkNode *&L) //完成本题的算法
> {	printf("排序前单链表 L:");
> 	DispList(L); //调用基本运算算法
> 	Sort(L);
> 	printf("排序后单链表 L:");
> 	DispList(L); //调用基本运算算法
> 	printf("释放单链表 L\n");
> 	DestroyList(L); //调用基本运算算法
> }
> 
## 16. 设有一个双链表 h，每个结点中除有 $prior、data$ 和 $next$ 三个域外，还有一个访问频度域 freq，在链表被起用之前，其值均初始化为零。每当进行 LocateNode($h，x$)运算时，令元素值为 $x$ 的结点中 $freq$ 域的值加 1，并调整表中结点的次序，使其按访问频度的递减序排列，以便使频繁访问的结点总是靠近表头。试写一符合上述要求的 LocateNode 运算的算法。
> 解：在 DLinkNode 类型的定义中添加整型 $freq$ 域，给该域初始化为 0。在每次查找到一个结点 $p$ 时，将其 $freq$ 域增 1，再与它前面的一个结点 $pre$ 进行比较，若 $p$ 结点的 $freq$ 域值较大，则两者交换，如此找一个合适的位置。对应的算法如下：
> ```c
> bool LocateNode(DLinkNode *h,ElemType x)
> {	DLinkNode *p=h->next,*pre;
> 	while (p!=NULL && p->data!=x)
> 		p=p->next; //找 data 域值为 x 的结点 p
> 	if (p==NULL) //未找到的情况
> 		return false;
> 	else //找到的情况
> 	{	p->freq++; //频度增 1
> 		pre=p->prior; //结点 pre 为结点 p 的前驱结点
> 		while (pre!=h && pre->freq<p->freq)
> 		{	p->prior=pre->prior;
> 			p->prior->next=p; //交换结点 p 和结点 pre 的位置
> 			pre->next=p->next;
> 			if (pre->next!=NULL) //若 p 结点不是尾结点时
> 			pre->next->prior=pre;
> 			p->next=pre;pre->prior=p;
> 			pre=p->prior; //q 重指向结点 p 的前驱结点
> 		}
> 		return true;
> 	}
> }
> ```

## 17. 设 $ha=(a_{1}，a_{2}，…，a_{n})$ 和 $hb=(b_{1}，b_{2}， …，b_{m})$ 是两个带头结点的循环单链表。设计一个算法将这两个表合并为带头结点的循环单链表 $hc$。
> 解：先找到 ha 的尾结点 p，将结点 p 的 next 指向 hb 的首结点，再找到 hb 的尾结点 p，将其构成循环单链表。对应的算法如下：
> ```c
> void Merge(LinkNode *ha, LinkNode *hb, LinkNode *&hc)
> {	LinkNode *p=ha->next;
> 	hc=ha;
> 	while (p->next!=ha) //找到 ha 的尾结点 p
> 		p=p->next;
> 	p->next=hb->next; //将结点 p 的 next 指向 hb 的首结点
> 	while (p->next!=hb)
> 		p=p->next; //找到 hb 的尾结点 p
> 	p->next=hc; //构成循环单链表
> 	free(hb); //释放 hb 单链表的头结点
> }
> ```

## 18. 设两个非空线性表分别用带头结点的循环双链表 $ha$ 和 $hb$ 表示。设计一个算法Insert($ha，hb，i$)。其功能是：$i$=0 时，将 $hb$ 插入到 $ha$ 的前面；当 $i$>0 时，将 $hb$ 插入到 $ha$中第 $i$ 个结点的后面；当 $i$ 大于等于 $ha$ 的长度时，将 $hb$ 插入到 $ha$ 的后面。
> 解：利用带头结点的循环双链表的特点设计的算法如下：
> ```c
> void Insert(DLinkNode *&ha, DLinkNode *&hb,int i)
> {	DLinkNode *p=ha->next,*post;
> 	int lena=1,j;
> 	while (p->next!=ha) //求出 ha 的长度 lena
> 	{	lena++;
> 		p=p->next;
> 	}
> 	if (i==0) //将 hb 插入到 ha 的前面
> 	{	p=hb->prior; //p 指向 hb 的尾结点
> 		p->next=ha->next; //将结点 p 链到 ha 的首结点前面
> 		ha->next->prior=p;
> 		ha->next=hb->next;
> 		hb->next->prior=ha; //将 ha 头结点与 hb 的首结点链起来
> 	}
> 	else if (i<lena) //将 hb 插入到 ha 中间
> 	{	j=1;
> 		p=ha->next;
> 		while (j<i) //在 ha 中查找第 i 个结点 p
> 		{	p=p->next;
> 			j++;
> 		}
> 		post=p->next; //post 指向 p 结点的后继结点
> 		p->next=hb->next; //将 hb 的首结点作为 p 结点的后继结点
> 		hb->next->prior=p;
> 		hb->prior->next=post; //将 post 结点作为 hb 尾结点的后继结点
> 		post->prior=hb->prior;
> 	}
> 	else //将 hb 链到 ha 之后
> 	{	ha->prior->next=hb->next; //ha->prior 指向 ha 的尾结点
> 		hb->next->prior=ha->prior;
> 		hb->prior->next=ha;
> 		ha->prior=hb->prior;
> 	}
> 	free(hb); //释放 hb 头结点
> }
> ```

## 19. 用带头结点的单链表表示整数集合，完成以下算法并分析时间复杂度：
（1）设计一个算法求两个集合A和B的并集运算即 $C=A \cup B$。要求不破坏原有的单链表 $A$ 和 $B$。
（2）假设集合中的元素按递增排列，设计一个高效算法求两个集合 $A$ 和 $B$ 的并集运算即 $C=A \cup B$ 。要求不破坏原有的单链表 $A$ 和 $B$。
> 解：（1）集合 $A、B、C$ 分别用单链表 $ha、hb、hc$ 存储。采用尾插法创建单链表 $hc$，先将 $ha$ 单链表中所有结点复制到 $hc$ 中，然后扫描单链表 $hb$，将其中所有不属于 $ha$ 的结点复制到 $hc$ 中。对应的算法如下：
> ```c
> void Union1(LinkNode *ha,LinkNode *hb,LinkNode *&hc)
> {	LinkNode *pa=ha->next,*pb=hb->next,*pc,*rc;
> 	hc=(LinkNode *)malloc(sizeof(LinkNode));
> 	rc=hc;
> 	while (pa!=NULL) //将 A 复制到 C 中
> 	{	pc=(LinkNode *)malloc(sizeof(LinkNode));
> 		pc->data=pa->data;
> 		rc->next=pc;
> 		rc=pc;
> 		pa=pa->next;
> 	}
> 	while (pb!=NULL) //将 B 中不属于 A 的元素复制到 C 中
> 	{	pa=ha->next;
> 		while (pa!=NULL && pa->data!=pb->data)
> 		pa=pa->next;
> 		if (pa==NULL) //pb->data 不在 A 中
> 		{	pc=(LinkNode *)malloc(sizeof(LinkNode));
> 			pc->data=pb->data;
> 			rc->next=pc;
> 			rc=pc;
> 		}
> 		pb=pb->next;
> 	}
> 	rc->next=NULL; //尾结点 next 域置为空
> }
> ```
>  &emsp;  &emsp;本算法的时间复杂度为 O($m×n$)，其中 m、n 为单链表 ha 和 hb 中的数据结点个数。
>  &nbsp;
>（2）同样采用尾插法创建单链表 $hc$，并利用单链表的有序性，采用二路归并方法来提高算法效率。对应的算法如下：
> ```c
> void Union2(LinkNode *ha,LinkNode *hb,LinkNode *&hc)
> {	LinkNode *pa=ha->next,*pb=hb->next,*pc,*rc;
> 	hc=(LinkNode *)malloc(sizeof(LinkNode));
> 	rc=hc;
> 	while (pa!=NULL && pb!=NULL)
> 	{	if (pa->data<pb->data) //将较小的结点 pa 复制到 hc 中
> 		{	pc=(LinkNode *)malloc(sizeof(LinkNode));
> 			pc->data=pa->data;
> 			rc->next=pc;
> 			rc=pc;
> 			pa=pa->next;
> 		}
> 		else if (pa->data>pb->data) //将较小的结点 pb 复制到 hc 中
> 		{	pc=(LinkNode *)malloc(sizeof(LinkNode));
> 			pc->data=pb->data;
> 			rc->next=pc;
> 			rc=pc;
> 			pb=pb->next;
> 		}
> 		else //相等的结点只复制一个到 hc 中
> 		{	pc=(LinkNode *)malloc(sizeof(LinkNode));
> 			pc->data=pa->data;
> 			rc->next=pc;
> 			rc=pc;
> 			pa=pa->next;
> 			pb=pb->next;
> 		}
> 	}
> 	if (pb!=NULL) pa=pb; //让 pa 指向没有扫描完的单链表结点
> 	while (pa!=NULL)
> 	{	pc=(LinkNode *)malloc(sizeof(LinkNode));
> 		pc->data=pa->data;
> 		rc->next=pc;
> 		rc=pc;
> 		pa=pa->next;
> 	}
> 	rc->next=NULL; //尾结点 next 域置为空
> }
> ```
>  &emsp;  &emsp;本算法的时间复杂度为 O(m+n)，其中 m、n 为单链表 ha 和 hb 中的数据结点个数。
>
## 20. 用带头结点的单链表表示整数集合，完成以下算法并分析时间复杂度：
（1）设计一个算法求两个集合A和B的差集运算即C=A-B。要求算法的空间复杂度为O(1)，并释放单链表A和B中不需要的结点。
（2）并假设集合中的元素按递增排列，设计一个高效算法求两个集合A和B的差集运算即C=A-B。要求算法的空间复杂度为O(1)，并释放单链表A和B中不需要的结点。
> 解：集合A、B、C分别用单链表ha、hb、hc存储。由于要求空间复杂度为O(1)，不能采用复制方法，只能利用原来单链表中结点重组产生结果单链表。
>  &emsp; （1）将 ha 单链表中所有在 hb 中出现的结点删除，最后将 hb 中所有结点删除。对应的算法如下：
> ```c
> void Sub1(LinkNode *ha,LinkNode *hb,LinkNode *&hc)
> {	LinkNode *prea=ha,*pa=ha->next,*pb,*p,*post;
> 	hc=ha; //将 ha 的头结点作为 hc 的头结点
> 	while (pa!=NULL) //删除 A 中属于 B 的结点
> 	{	pb=hb->next;
> 		while (pb!=NULL && pb->data!=pa->data)
> 		pb=pb->next;
> 		if (pb!=NULL) //pa->data 在 B 中,从 A 中删除结点 pa
> 		{	prea->next=pa->next;
> 			free(pa);
> 			pa=prea->next;
> 		}
> 		else
> 		{	prea=pa; //prea 和 pa 同步后移
> 			pa=pa->next;
> 		}
> 	}
> 	p=hb; post=hb->next; //释放 B 中所有结点
> 	while (post!=NULL)
> 	{	free(p);
> 		p=post;
> 		post=post->next;
> 	}
> 	free(p);
> }
> ```
> 本算法的时间复杂度为 O(m×n)，其中 m、n 为单链表 ha 和 hb 中的数据结点个数。
>  &emsp; （2）同样采用尾插法创建单链表 hc，并利用单链表的有序性，采用二路归并方法来提高算法效率，一边比较一边将不需要的结点删除。对应的算法如下：
> ```c
> void Sub2(LinkNode *ha,LinkNode *hb,LinkNode *&hc)
> {	LinkNode *prea=ha,*pa=ha->next; //pa 扫描 ha,prea 是 pa 结点的前驱结点指针
> 	LinkNode *preb=hb,*pb=hb->next; //pb 扫描 hb,preb 是 pb 结点的前驱结点指针
> 	LinkNode *rc; //hc 的尾结点指针
> 	hc=ha; //ha 的头结点作为 hc 的头结点
> 	rc=hc;
> 	while (pa!=NULL && pb!=NULL)
> 	{	if (pa->data<pb->data) //将较小的结点 pa 链到 hc 之后
> 		{	rc->next=pa;
> 			rc=pa;
> 			prea=pa; //prea 和 p 同步后移
> 			pa=pa->next;
> 		}
> 		else if (pa->data>pb->data) //删除较大的结点 pb
> 		{	preb->next=pb->next;
> 			free(pb);
> 			pb=preb->next;
> 		}
> 		else //删除相等的 pa 结点和 pb 结点
> 		{	prea->next=pa->next;
> 			free(pa);
> 			pa=prea->next;
> 			preb->next=pb->next;
> 			free(pb);
> 			pb=preb->next;
> 		}
> 	}
> 	while (pb!=NULL) //删除 pb 余下的结点
> 	{	preb->next=pb->next;
> 		free(pb);
> 		pb=preb->next;
>	}
> 	free(hb); //释放 hb 的头结点
> 	rc->next=NULL; //尾结点 next 域置为空
> }
> ```
>本算法的时间复杂度为 O(m+n)，其中 m、n 为单链表 ha 和 hb 中的数据结点个数。

---
# 第 3 章 栈和队列
## 1. 有5个元素，其进栈次序为：*A*、*B*、*C*、*D*、*E*，在各种可能的出栈次序中，以元素*C*、*D*最先出栈（即 *C* 第一个且 *D* 第二个出栈）的次序有哪几个？
>答：要使 *C* 第一个且 *D* 第二个出栈，应是 *A* 进栈，*B* 进栈，*C* 进栈，*C* 出栈，*D* 进栈，*D* 出栈，之后可以有以下几种情况：
&emsp; &emsp; （1）B出栈，A出栈，E进栈，E出栈，输出序列为CDBAE；
&emsp; &emsp; （2）B出栈，E进栈，E出栈，A出栈，输出序列为CDBEA；
&emsp; &emsp; （3）E进栈，E出栈，B出栈，A出栈，输出序列为CDEBA。
&emsp; &emsp; 所以可能的次序有：CDBAE、CDBEA、CDEBA。

## 2. 在一个算法中需要建立多个栈（假设 3 个栈或以上）时可以选用以下 3 种方案之一，试问这些方案之间相比各有什么优缺点？
&emsp; &emsp; （1）分别用多个顺序存储空间建立多个独立的顺序栈。
&emsp; &emsp; （2）多个栈共享一个顺序存储空间。
&emsp; &emsp; （3）分别建立多个独立的链栈。
> 答：（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。
&emsp; &emsp; （2）优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈顶指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。
&emsp; &emsp; （3）优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。

## 3. 在以下几种存储结构中，哪个最适合用作链栈？
&emsp; &emsp; （1）带头结点的单链表
&emsp; &emsp; （2）不带头结点的循环单链表
&emsp; &emsp; （3）带头结点的双链表
> 答：栈中元素之间的逻辑关系属线性关系，可以采用单链表、循环单链表和双链表之一来存储，而栈的主要运算是进栈和出栈。
&emsp; &emsp; 当采用（1）时，前端作为栈顶，进栈和出栈运算的时间复杂度为 O(1)。
&emsp; &emsp; 当采用（2）时，前端作为栈顶，当进栈和出栈时，首结点都发生变化，还需要找到尾结点，通过修改其 next 域使其变为循环单链表，算法的时间复杂度为 O($n$)。
&emsp; &emsp; 当采用（3）时，前端作为栈顶，进栈和出栈运算的时间复杂度为 O(1)。
&emsp; &emsp; 但单链表和双链表相比，其存储密度更高，所以本题中最适合用作链栈的是带头结点的单链表。

## 4. 简述以下算法的功能（假设 ElemType 为 int 类型）：
```c
void fun(ElemType a[],int n)
{	int i; ElemType e;
	SqStack *st1,*st2;
	InitStack(st1);
	InitStack(st2);
	for (i=0;i<n;i++)
		if (a[i]%2==1)
			Push(st1,a[i]);
		else
			Push(st2,a[i]);
	i=0;
	while (!StackEmpty(st1))
	{	Pop(st1,e);
		a[i++]=e;
	}
	while (!StackEmpty(st2))
	{	Pop(st2,e);
		a[i++]=e;
	}
	DestroyStack(st1);
	DestroyStack(st2);
}
```
> 答：算法的执行步骤如下：
&emsp; &emsp; （1）扫描数组 a，将所有奇数进到 st1 栈中，将所有偶数进到 st2 栈中。
&emsp; &emsp; （2）先将 st1 的所有元素（奇数元素）退栈，并放到数组 a 中并覆盖原有位置的元素；
再将 st2 的所有元素（偶数元素）退栈，并放到数组 a 中并覆盖原有位置的元素。
&emsp; &emsp; （3）销毁两个栈 st1 和 st2。
所以本算法的功能是，利用两个栈将数组 a 中所有的奇数元素放到所有偶数元素的前面。例如，ElemType a[]={1,2,3,4,5,6}，执行算法后数组 a 改变为{5,3,1,6,4,2}。

## 5. 简述以下算法的功能（顺序栈的元素类型为 ElemType）。
```c
void fun(SqStack *&st,ElemType x)
{	SqStack *tmps;
	ElemType e;
	InitStack(tmps);
	while(!StackEmpty(st))
	{	Pop(st,e);
		if(e!=x) Push(tmps,d);
	}
	while (!StackEmpty(tmps))
	{	Pop(tmps,e);
		Push(st,e);
	}
	DestroyStack(tmps);
}
```
> 答：算法的执行步骤如下：
&emsp; &emsp; （1）建立一个临时栈 $tmps$ 并初始化。
&emsp; &emsp; （2）退栈 $st$ 中所有元素，将不为 $x$ 的元素进栈到 $tmps$ 中。
&emsp; &emsp; （3）退栈 $tmps$ 中所有元素，并进栈到 $st$ 中。
&emsp; &emsp; （4）销毁栈 $tmps$。
&emsp; &emsp; 所以本算法的功能是，如果栈 $st$ 中存在元素 $x$，将其从栈中清除。例如，$st$ 栈中从栈底到栈顶为 $a、b、c、d、e$，执行算法 fun($st，'c'$)后，$st$ 栈中从栈底到栈顶为 $a、b、d、e$。

## 6. 简述以下算法的功能（栈 st 和队列 qu 的元素类型均为 ElemType）。
```c
bool fun(SqQueue *&qu,int i)
{	ElemType e;
	int j=1;
	int n=(qu->rear-qu->front+MaxSize)%MaxSize;
	if (j<1 || j>n) return false;
	for (j=1;j<=n;j++)
	{	deQueue(qu,e);
		if (j!=i)
		enQueue(qu,e);
	}
	return true;
}
```

> 答：算法的执行步骤如下：
&emsp; &emsp; （1）求出队列 $qu$ 中的元素个数 $n$。参数 $i$ 错误时返回假。
&emsp; &emsp; （2）$qu$ 出队共计 $n$ 次，除了第 $i$ 个出队的元素外，其他出队的元素立即进队。
&emsp; &emsp; （3）返回真。
&emsp; &emsp; 所以本算法的功能是，删除 $qu$ 中从队头开始的第 $i$ 个元素。例如，$qu$ 中从队头到队尾的元素是 $a、b、c、d、e$，执行算法 fun($qu，2$)后，qu 中从队头到队尾的元素改变为 $a、c、d、e$。

## 7. 什么是环形队列？采用什么方法实现环形队列？
> 答：当用数组表示队列时，把数组看成是一个环形的，即令数组中第一个元素紧跟在最末一个单元之后，就形成一个环形队列。环形队列解决了非环形队列中出现的“假溢出”现象。
&emsp; &emsp; 通常采用逻辑上求余数的方法来实现环形队列，假设数组的大小为 n，当元素下标 $i$ 增 1 时，采用 $i=(i+1)$%$n$ 来实现。

## 8. 环形队列一定优于非环形队列吗？什么情况下使用非环形队列？
> 答：队列主要是用于保存中间数据，而且保存的数据满足先产生先处理的特点。非环形队列可能存在数据假溢出，即队列中还有空间，可是队满的条件却成立了，为此改为环形队列，这样克服了假溢出。但并不能说环形队列一定优于非环形队列，因为环形队列中出队元素的空间可能被后来进队的元素覆盖，如果算法要求在队列操作结束后利用进队的所有元素实现某种功能，这样环形队列就不适合了，这种情况下需要使用非环形队列，例如利用非环形队列求解迷宫路径就是这种情况。

## 9. 假设以 I 和 O 分别表示进栈和出栈操作，栈的初态和终栈均为空，进栈和出栈的操作序列可表示为仅由 I 和 O 组成的序列。
&emsp; &emsp; （1）下面所示的序列中哪些是合法的？
&emsp; &emsp; &emsp; &emsp; A.IOIIOIOO &emsp; B.IOOIOIIO &emsp; C.IIIOIOIO &emsp; D.IIIOOIOO
&emsp; &emsp; （2）通过对（1）的分析，设计一个算法判定所给的操作序列是否合法。若合法返回真；否则返回假。（假设被判定的操作序列已存入一维数组中）。

> 解：（1）选项A、D均合法，而选项B、C不合法。因为在选项B中，先进栈一次，立即出栈3次，这会造成栈下溢。在选项C中共进栈5次，出栈3次，栈的终态不为空。
&emsp; （2）本题使用一个链栈来判断操作序列是否合法，其中 $str$ 为存放操作序列的字符数组，$n$ 为该数组的字符个数（这里的 ElemType 类型设定为 char）。对应的算法如下：
> ```c
> bool judge(char str[],int n)
> {	int i=0; ElemType x;
> 	LinkStNode *ls;
> 	bool flag=true;
> 	InitStack(ls);
> 	while (i<n && flag)
> 	{	if (str[i]=='I') //进栈
> 		Push(ls,str[i]);
> 		else if (str[i]=='O') //出栈
> 		{	if (StackEmpty(ls))
> 				flag=false; //栈空时
>			else
> 				Pop(ls,x);
> 		}
> 		else
> 			flag=false; //其他值无效
> 		i++;
> 	}
> 	if (!StackEmpty(ls)) flag=false;
> 	DestroyStack(ls);
> 	return flag;
> }
> ```

## 10. 假设表达式中允许包含 3 种括号：圆括号、方括号和大括号。编写一个算法判断表达式中的括号是否正确配对。
> 解：设置一个栈 $st$，扫描表达式 $exp$，遇到 ‘(’、‘[’ 或 ‘{’，则将其进栈；遇到 ‘)’ ，若栈顶是 ‘(’，则继续处理，否则以不配对返回假；遇到 ‘]’，若栈顶是 ‘[’，则继续处理，否则以不配对返回假；遇到 ‘}’，若栈顶是 ‘{’，则继续处理，否则以不配对返回假。在 $exp$ 扫描完毕，若栈不空，则以不配对返回假；否则以括号配对返回真。本题算法如下：
> ```c
> bool Match(char exp[],int n)
> {	LinkStNode *ls;
> 	InitStack(ls);
> 	int i=0;
> 	ElemType e;
> 	bool flag=true;
> 	while (i<n && flag)
> 	{	if (exp[i]=='(' || exp[i]=='[' || exp[i]=='{')
> 			Push(ls,exp[i]); //遇到'('、'['或'{',则将其进栈
> 		if (exp[i]==')') //遇到')',若栈顶是'(',则继续处理,否则以不配对返回
> 		{	if (GetTop(ls,e))
> 			{	if (e=='(') Pop(ls,e);
> 				else flag=false;
> 			}
> 			else flag=false;
> 		}
> 		if (exp[i]==']') //遇到']',若栈顶是'[',则继续处理,否则以不配对返回
> 		{	if (GetTop(ls,e))
> 			{	if (e=='[') Pop(ls,e);
> 				else flag=false;
> 			}
> 			else flag=false;
> 		}
> 		if (exp[i]=='}') //遇到'}',若栈顶是'{',则继续处理,否则以不配对返回
> 		{	if (GetTop(ls,e))
> 			{	if (e=='{') Pop(ls,e);
> 				else flag=false;
> 			}
> 			else flag=false;
> 		}
> 		i++;
> 	}
> 	if (!StackEmpty(ls)) flag=false; //若栈不空,则不配对
> 	DestroyStack(ls);
> 	return flag;
> }
> ```
## 11. 设从键盘输入一序列的字符 $a_{1}、a_{2}、···、a_{n}$。设计一个算法实现这样的功能：若 $a_{i}$ 为数字字符，$a_{i}$ 进队，若 $a_{i}$ 为小写字母时，将队首元素出队，若 $a_{i}$ 为其他字符，表示输入结束。要求使用环形队列。
> 解：先建立一个环形队列 qu，用 while 循环接收用户输入，若输入数字字符，将其进队；若输入小写字母，出队一个元素，并输出它；若为其他字符，则退出循环。本题算法如下：
> ```c
> void fun()
> { 	ElemType a,e;
> 	SqQueue *qu; //定义队列指针
> 	InitQueue(qu);
> 	while (true)
> 	{	printf("输入 a:");
> 		scanf("%s",&a);
> 		if (a>='0' && a<='9') //为数字字符
> 		{	if (!enQueue(qu,a))
> 				printf(" 队列满,不能进队\n");
> 		}
> 		else if (a>='a' && a<='z') //为小写字母
> 		{	if (!deQueue(qu,e))
> 				printf(" 队列空,不能出队\n");
> 			else
> 				printf(" 出队元素:%c\n",e);
> 		}
> 		else break; //为其他字符
> 		}
> 	DestroyQueue(qu);
> }
> ```

## 12. 设计一个算法，将一个环形队列（容量为 n，元素下标从 0 到 n-1）的元素倒置。例如，图 3.2（a）中为倒置前的队列（$n$=10），图 3.2（b）中为倒置后的队列。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501172609512.png#pic_center)
<center>图 3.2 一个环形队列倒置前后的状态</center>

> 解：使用一个临时栈 $st$，先将 $qu$ 队列中所有元素出队并将其进栈 $st$，直到队列空为止。然后初始化队列 $qu$（队列清空），再出栈 $st$ 的所有元素并将其进队 $qu$，最后销毁栈 $st$。对应的算法如下：
> ```c
> void Reverse(SqQueue *&qu)
> {	ElemType e;
> 	SqStack *st;
> 	InitStack(st);
> 	while (!QueueEmpty(qu)) //队不空时,出队并进栈
> 	{	deQueue(qu,e);
> 		Push(st,e);
> 	}
> 	InitQueue(qu); //队列初始化
> 	while (!StackEmpty(st)) //栈不空时,出栈并将元素入队
> 	{	Pop(st,e);
> 		enQueue(qu,e);
> 	}
> 	DestroyStack(st);
> }
> ```

## 13. 编写一个程序，输入 $n$（由用户输入）个 10 以内的数，每输入 $i$（$0 \leqslant i \leqslant 9$），就把它插入到第 i 号队列中。最后把 10 个队中非空队列，按队列号从小到大的顺序串接成一条链，并输出该链的所有元素。
> 解：建立一个队头指针数组 quh 和队尾指针数组 $qut$，$quh[i]$和 $qut[i]$表示 $i$ 号（$0 \leqslant i \leqslant 9$）队列的队头和队尾，先将它们所有元素置为 NULL。对于输入的 x，采用尾插法将其链到 $x$ 号队列中。然后按 0～9 编号的顺序把这些队列中的结点构成一个不带头结点的单链表，其
首结点指针为 head。最后输出单链表 head 的所有结点值并释放所有结点。对应的程序如下：
>  ```c
> #include <stdio.h>
> #include <malloc.h>
> #define MAXQNode 10 //队列的个数
> typedef struct node {
>     int data;
>     struct node *next;
> } QNode;
> 
> void Insert(QNode *quh[], QNode *qut[], int x) //将 x 插入到相应队列中
> {
>     QNode *s;
>     s = (QNode *) malloc(sizeof(QNode)); //创建一个结点 s
>     s->data = x;
>     s->next = NULL;
>     if (quh[x] == NULL) //x 号队列为空队时
>     {
>         quh[x] = s;
>         qut[x] = s;
>     } else //x 号队列不空队时
>     {
>         qut[x]->next = s; //将 s 结点链到 qut[x]所指结点之后
>         qut[x] = s; //让 qut[x]仍指向尾结点
>     }
> }
> 
> void Create(QNode *quh[], QNode *qut[]) //根据用户输入创建队列
> {
>     int n, x, i;
>     printf("n:");
>     scanf("%d", &n);
>     for (i = 0; i < n; i++) {
>         do {
>             printf("输入第%d 个数:", i + 1);
>             scanf("%d", &x);
>         } while (x < 0 || x > 10);
>         Insert(quh, qut, x);
>     }
> }
> 
> void DestroyList(QNode *&head) //释放单链表
> {
>     QNode *pre = head, *p = pre->next;
>     while (p != NULL) {
>         free(pre);
>         pre = p;
>         p = p->next;
>     }
>     free(pre);
> }
> 
> void DispList(QNode *head) //输出单链表的所有结点值 
> {
>     printf("\n 输出所有元素:");
>     while (head != NULL) {
>         printf("%d ", head->data);
>         head = head->next;
>     }
>     printf("\n");
> }
> 
> QNode *Link(QNode *quh[], QNode *qut[]) //将非空队列链接起来并输出
> {
>     QNode *head = NULL, *tail; //总链表的首结点指针和尾结点指针
>     int i;
>     for (i = 0; i < MAXQNode; i++) //扫描所有队列
>         if (quh[i] != NULL) //i 号队列不空
>         {
>             if (head == NULL) //若 i 号队列为第一个非空队列
>             {
>                 head = quh[i];
>                 tail = qut[i];
>             } else //若 i 号队列不是第一个非空队列
>             {
>                 tail->next = quh[i];
>                 tail = qut[i];
>             }
>         }
>     tail->next = NULL;
>     return head;
> }
> 
> int main() {
>     int i;
>     QNode *head;
>     QNode *quh[MAXQNode], *qut[MAXQNode]; //各队列的队头 quh 和队尾指针 qut
>     for (i = 0; i < MAXQNode; i++)
>         quh[i] = qut[i] = NULL; //置初值空
>     Create(quh, qut); //建立队列
>     head = Link(quh, qut); //链接各队列产生单链表
>     DispList(head); //输出单链表
>     DestroyList(head); //销毁单链表
>     return 1;
> }


# 第 4 章 串
## 1. 串是一种特殊的线性表，请从存储和运算两方面分析它的特殊之处。
> 答：从存储方面看，串中每个元素是单个字符，在设计串存储结构时可以每个存储单元或者结点只存储一个字符。从运算方面看，串有连接、判串相等、求子串和子串替换等基本运算，这是线性表的基本运算中所没有的。

## 2. 为什么模式匹配中，BF 算法是有回溯算法，而 KMP 算法是无回溯算法？
> 答：设目标串为 $s$，模式串为 $t$。在 BF 算法的匹配过程中，当 $t[j]=s[i]$时，置 $i++$，$j++$；当 $t[j] \neq s[i]$时，置 $i=i-j+1$，$j=0$。从中看到，一旦两字符不等，目标串指针 $i$ 会回退，所以 BF 算法是有回溯算法。在 KMP 算法的匹配过程中，当 $t[j]=s[i]$时，置 $i++$，$j++$；当 $t[j] \neq s[i]$ 时，$i$ 不变，置 $j=next[j]$。从中看到，目标串指针 $i$ 不会回退，只会保持位置不变或者向前推进，所以 KMP 算法是无回溯算法。

## 3. 在 KMP 算法中，计算模式串的 $next$ 时，当 $j=0$ 时，为什么要置 $next[0]=-1$？
> 答：当模式串中 $t_{0}$ 字符与目标串中某字符 $s_{i}$ 比较不相等时，此时置 $next[0]=-1$ 表示模式串中已没有字符可与目标串的 $s_{i}$ 比较，目标串当前指针 $i$ 应后移至下一个字符，再和模式串的 $t_{0}$ 字符进行比较。
## 4. KMP 算法是简单模式匹配算法的改进，以目标串 $s$="$aabaaabc$"、模式串 $t$="$aaabc$" 为例说明的 $next$ 的作用。
> 答：模式串 t="$aaabc$"的 $next$ 数组值如表 4.1 所示。
> $j$ | 0 | 1 | 2 | 3 | 4
> -- | -- | -- | -- | -- | --
> $t[j]$ | $a$ | $a$ | $a$ | $b$ | $c$
> $next[j]$ | -1 | 0 | 1 | 2 | 0
> <center>表 4.1 模式串 t 对应的 next 数组</center>
> 
> &emsp;&emsp;从 i=0，j=0 开始，当两者对应字符相等时，$i++$，$j++$，直到 $i$=2，$j$=2 时对应字符不相等。如果是简单模式匹配，下次从 $i$=1，$j$=0 开始比较。
> &emsp;&emsp;KMP 算法已经获得了前面字符比较的部分匹配信息，即 $s[0..1]=t[0..1]$，所以 $s[0]=t[0]$，而 $next[2]=1$ 表明 $t[0]=t[1]$，所以有$s[0]=t[1]$，这说明下次不必从 $i$=1，$j$=0 开始比较，而只需保持 $i$=2 不变，让 $i$=2 和 $j$=$next[j]$=1 的字符进行比较。  
> &emsp;&emsp;$i$=2，$j$=1 的字符比较不相等，保持 $i$=2 不变，取 $j$=$next[j]$=0。
> &emsp;&emsp;$i$=2，$j$=0 的字符比较不相等，保持 $i$=2 不变，取 $j$=$next[j]$=-1。
> &emsp;&emsp;当 $j$=-1 时 $i$++、$j$++，则 $i$=3，$j$=0，对应的字符均相等，一直比较到 $j$ 超界，此时表示匹配成功，返回 3。
> &emsp;&emsp;从中看到，$next[j]$保存了部分匹配的信息，用于提高匹配效率。由于是在模式串的 $j$ 位置匹配失败的，$next$ 也称为失效函数或失配函数。
## 5. 给出以下模式串的 $next$ 值和 $nextval$ 值：
&emsp;&emsp;（1）ababaa
&emsp;&emsp;（2）abaabaab
> 答：（1）求其 next 和 nextval 值如表 4.2 所示。
> j | 0 | 1 | 2 | 3 | 4 | 5
> -- | -- | -- | -- | -- | -- | --
> t[j] | a | b | a | b | a | a
> next[j] | -1 | 0 | 0 | 1 | 2 | 3
> nextval[j] | -1 | 0 | -1 | 0 | -1 | 3
> <center>表 4.2 模式串"ababaa"对应的 next 数组</center>
> 
> （2）求其 next 和 nextval 值如表 4.3 所示。

> j | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
> -- | -- | -- | -- | -- | -- | -- | -- | --
> t[j] | a | b | a | a | b | a | a | b
> next[j] | -1 | 0 | 0 | 1 | 1 | 2 | 3 | 4
> nextval[j] | -1 | 0 | -1 | 1 | 0 | -1 | 1 | 0
> <center>表 4.3 模式串"abaabaab"对应的 next 数组</center>

## 6. 设目标为 s="abcaabbabcabaacbacba"，模式串 t="abcabaa"。
&emsp;&emsp;（1）计算模式串 t 的 nextval 数组。
&emsp;&emsp;（2）不写算法，给出利用改进的KMP算法进行模式匹配的过程。
&emsp;&emsp;（3）问总共进行了多少次字符比较？
> 解：（1）先计算next数组，在此基础上求nextval数组，如表4.4所示。
> j | 0 | 1 | 2 | 3 | 4 | 5 | 6
>  -- | -- | -- | -- | -- | -- | -- | -- | --
> t[j] | a | b | c | a | b | a | a
> next[j] | -1 | 0 | 0 | 0 | 1 | 2 | 1
> nextval[j] | -1 | 0 | 0 | -1 | 0 | 2 | 1
> <center>表 4.4 计算 next 数组和 nextval 数组</center>
> （2）改进的 KMP 算法进行模式匹配的过程如图 4.2 所示。
> <center><img src="https://img-blog.csdnimg.cn/20200501181614464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM0MDEyOQ==,size_16,color_FFFFFF,t_70" width="100%"></center>
> <center>图 4.2 改进的 KMP 算法模式匹配的过程</center>
（3）从上述匹配过程看出：第 1 趟到第 4 趟的字符比较次数分别是 5、3、1、7，所以总共进行了 16 次字符比较。

## 7. 有两个顺序串 s1 和 s2，设计一个算法求一个顺序串 s3，该串中的字符是 s1 和 s2中公共字符（即两个串都包含的字符）。
> 解：扫描 $s1$，对于当前字符 $s1$.$data[i]$，若它在 $s2$ 中出现，则将其加入到串 $s3$ 中。最后返回 $s3$ 串。对应的算法如下：
> ```c
> SqString CommChar(SqString s1,SqString s2)
> {	SqString s3;
> 	int i,j,k=0;
> 	for (i=0;i<s1.length;i++)
> 	{	for (j=0;j<s2.length;j++)
> 			if (s2.data[j]==s1.data[i])
> 				break;
> 		if (j<s2.length) //s1.data[i]是公共字符
> 		{	s3.data[k]=s1.data[i];
> 			k++;
> 		}
> 	}
> 	s3.length=k;
> 	return s3;
> }
> ```

## 8. 采用顺序结构存储串，设计一个实现串通配符匹配的算法 pattern_index()，其中的通配符只有‘？’，它可以和任一个字符匹配成功。例如，pattern_index("？$re$"，"$there are$") 返回的结果是 2。
> 解：采用 BF 算法的穷举法的思路，只需要增加对‘?’字符的处理功能。对应的算法如下：
> ```c
> int index(SqString s,SqString t)
> {	int i=0,j=0;
> 	while (i<s.length && j<t.length)
> 	{	if (s.data[i]==t.data[j] || t.data[j]=='?')
> 		{	i++;
> 			j++;
> 		}
> 		else
> 		{	i=i-j+1;
> 			j=0;
> 		}
> 	}
> 	if (j>=t.length)
> 		return(i-t.length);
> 	else
> 	return(-1);
> }
> ```

## 9. 设计一个算法，在顺序串 s 中从后向前查找子串 t，即求 t 在 s 中最后一次出现的位置。
> 解：采用简单模式匹配算法。如果串 $s$ 的长度小于串 $t$ 的长度，直接返回 -1。然后 $i$ 从 $s.length - t.length$ 到 0 循环：再对于 $i$ 的每次取值循环：置 $j=i$，$k=0$，若 $s.data[j]==t.data[k]$，则 $j$++，$k$++。循环中当 $k == t.length$ 为真时，表示找到子串，返回物理下标 $i$。所有循环结束后都没有返回，表示串 $t$ 不是串 $s$ 的子串则返回-1。对应的算法如下：
> ```c
> int LastPos1(SqString s,SqString t)
> {	int i,j,k;
> 	if (s.length-t.length<0)
> 	return -1;
> 	for (i=s.length-t.length;i>=0;i--)
> 	{	for (j=i,k=0;j<s.length && k<t.length && s.data[j]==t.data[k];j++,k++);
> 		if (k==t.length)
> 		return i;
> 	}
> 	return -1;
> }
> ```

## 10. 设计一个算法，判断一个字符串 s 是否形如"序列 1@为序列 2"模式的字符序列，其中序列 1 和序列 2 都不含有'@'字符，且序列 2 是序列 1 的逆序列。例如"a+b@b+a"属于该模式的字符序列，而"1+3@3-1"则不是。
> 解：建立一个临时栈 $st$ 并初始化为空，其元素为 char 类型。置匹配标志 $flag$ 为 true。扫描顺序串 $s$ 的字符，将'@'之前的字符进栈。继续扫描顺序串 $s$ 中'@'之后的字符，每扫描一个字符 $e$，退栈一个字符 $x$，若退栈时溢出或 $e$ 不等于 $x$，则置 $flag$ 为 $false$。循环结束后，若栈不空，置 $flag$ 为 false。最后销毁栈 $st$ 并返回 $flag$。对应的算法如下：
> ```c
> bool symm(SqString s) {
>     int i = 0;
>     char e, x;
>     bool flag = true;
>     SqStack *st;
>     InitStack(st);
>     while (i < s.length) //将'@'之前的字符进栈
>     {
>         e = s.data[i];
>         if (e != '@')
>             Push(st, e);
>         else
>             break;
>         i++;
>     }
>     i++; //跳过@字符
>     while (i < s.length && flag) {
>         e = s.data[i];
>         if (!Pop(st, x)) flag = false;
>         if (e != x) flag = false;
>         i++;
>     }
>     if (!StackEmpty(st)) flag = false;
>     DestroyStack(st);
>     return flag;
> }
> ```

## 11. 采用顺序结构存储串，设计一个算法求串 s 中出现的第一个最长重复子串的下标和长度。
> 解：采用简单模式匹配算法的思路，先给最长重复子串的起始下标 maxi 和长度 maxlen 均赋值为 0。用 i 扫描串 s，对于当前字符 si，判定其后是否有相同的字符，若有记为 sj，再判定 si+1 是否等于 sj+1，si+2 是否等于 sj+2，…，直至找到一个不同的字符为止，即找到一个重复出现的子串，把其起始下标 i 与长度 len 记下来，将 len 与 maxlen 相比较，保留较长的子串 maxi 和 maxlen。再从 sj+len 之后查找重复子串。然后对于 si+1之后的字符采用上述过程。循环结束后，maxi 与 maxlen 保存最长重复子串的起始下标与长度，将其复制到串 t 中。
对应的算法如下：
> ```c
> void maxsubstr(SqString s, SqString &t) {
>     int maxi = 0, maxlen = 0, len, i, j, k;
>     i = 0;
>     while (i < s.length) //从下标为 i 的字符开始
>     {
>         j = i + 1; //从 i 的下一个位置开始找重复子串
>         while (j < s.length) {
>             if (s.data[i] == s.data[j]) //找一个子串,其起始下标为 i,长度为 len
>             {
>                 len = 1;
>                 for (k = 1; s.data[i + k] == s.data[j + k]; k++)
>                     len++;
>                 if (len > maxlen) //将较大长度者赋给 maxi 与 maxlen
>                 {
>                     maxi = i;
>                     maxlen = len;
>                 }
>                 j += len;
>             } else j++;
>         }
>         i++; //继续扫描第 i 字符之后的字符
>     }
>     t.length = maxlen; //将最长重复子串赋给 t
>     for (i = 0; i < maxlen; i++)
>         t.data[i] = s.data[maxi + i];
> }
> ```

## 12. 用带头结点的单链表表示链串，每个结点存放一个字符。设计一个算法，将链串 s中所有值为 x 的字符删除。要求算法的时间复杂度均为 O(n)，空间复杂度为 O(1)。
> 解：让 pre 指向链串头结点，p 指向首结点。当 p 不为空时循环：当 p->data==x 时，通过 pre 结点删除 p 结点，再让 p 指向 pre 结点的后继结点；否则让 pre、p 同步后移一个结点。对应的算法如下：
> ```c
> void deleteall(LinkStrNode *&s, char x) {
>     LinkStrNode *pre = s, *p = s->next;
>     while (p != NULL) {
>         if (p->data == x) {
>             pre->next = p->next;
>             free(p);
>             p = pre->next;
>         } else {
>             pre = p; //pre、p 同步后移
>             p = p->next;
>         }
>     }
> }
> ```





